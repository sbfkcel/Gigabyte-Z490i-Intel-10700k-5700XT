
/* Class = "NSButtonCell"; title = "DiscardHibernateMap"; ObjectID = "2QZ-Md-QHk"; */
"2QZ-Md-QHk.title" = "DiscardHibernateMap";

/* Class = "NSTableColumn"; headerCell.title = "Mask"; ObjectID = "3Ee-Qq-8wZ"; */
"3Ee-Qq-8wZ.headerCell.title" = "Mask";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean \nFailsafe: false\nDescription: Protect UEFI services from being overridden by the firmware.\n\nSome modern firmware, including on virtual machines such as VMware, may update pointers to UEFI services during driver loading and related actions. Consequently, this directly obstructs other quirks that affect memory management, such as DevirtualiseMmio, ProtectMemoryRegions, or RebuildAppleMemoryMap, and may also obstruct other quirks depending on the scope of such.\n\nNote: On VMware, the need for this quirk may be determined by the appearance of the “Your Mac OS guest might run unreliably with more than one virtual core.” message."; ObjectID = "3fG-t6-MF7"; */
"3fG-t6-MF7.ibShadowedToolTip" = "Type: plist boolean \nFailsafe: false\nDescription: Protect UEFI services from being overridden by the firmware.\n\nSome modern firmware, including on virtual machines such as VMware, may update pointers to UEFI services during driver loading and related actions. Consequently, this directly obstructs other quirks that affect memory management, such as DevirtualiseMmio, ProtectMemoryRegions, or RebuildAppleMemoryMap, and may also obstruct other quirks depending on the scope of such.\n\nNote: On VMware, the need for this quirk may be determined by the appearance of the “Your Mac OS guest might run unreliably with more than one virtual core.” message.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Protect memory regions from incorrect access.\n\nSome types of firmware incorrectly map certain memory regions:\n• The CSM region can be marked as boot services code, or data, which leaves it as free memory for XNU kernel.\n• MMIO regions can be marked as reserved memory and stay unmapped. They may however be required to be accessible at runtime for NVRAM support.\n\nThis quirk attempts to fix the types of these regions, e.g. ACPI NVS for CSM or MMIO for MMIO.\n\nNote: The need for this quirk is determined by artifacts, sleep wake issues, and boot failures. This quirk is typically only required by very old firmware."; ObjectID = "5Km-5w-nkl"; */
"5Km-5w-nkl.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Protect memory regions from incorrect access.\n\nSome types of firmware incorrectly map certain memory regions:\n• The CSM region can be marked as boot services code, or data, which leaves it as free memory for XNU kernel.\n• MMIO regions can be marked as reserved memory and stay unmapped. They may however be required to be accessible at runtime for NVRAM support.\n\nThis quirk attempts to fix the types of these regions, e.g. ACPI NVS for CSM or MMIO for MMIO.\n\nNote: The need for this quirk is determined by artifacts, sleep wake issues, and boot failures. This quirk is typically only required by very old firmware.";

/* Class = "NSButtonCell"; title = "ForceExitBootServices"; ObjectID = "5sK-91-1dQ"; */
"5sK-91-1dQ.title" = "ForceExitBootServices";

/* Class = "NSTableColumn"; headerCell.title = "Enabled"; ObjectID = "6o1-1f-ghJ"; */
"6o1-1f-ghJ.headerCell.title" = "Enabled";

/* Class = "NSTableColumn"; headerCell.title = "Find"; ObjectID = "7mi-i8-NsB"; */
"7mi-i8-NsB.headerCell.title" = "Find";

/* Class = "NSTableColumn"; headerCell.title = "Arch"; ObjectID = "82c-6J-7Bc"; */
"82c-6J-7Bc.headerCell.title" = "Arch";

/* Class = "NSButtonCell"; title = "SignalAppleOS"; ObjectID = "9fL-0g-rLi"; */
"9fL-0g-rLi.title" = "SignalAppleOS";

/* Class = "NSButtonCell"; title = "EnableSafeModeSlide"; ObjectID = "9lc-VM-DSq"; */
"9lc-VM-DSq.title" = "EnableSafeModeSlide";

/* Class = "NSButtonCell"; title = "ProtectUefiServices"; ObjectID = "9qv-tK-N7C"; */
"9qv-tK-N7C.title" = "ProtectUefiServices";

/* Class = "NSTableColumn"; headerCell.title = "Identifier"; ObjectID = "BvG-CB-C9w"; */
"BvG-CB-C9w.headerCell.title" = "Identifier";

/* Class = "NSTextFieldCell"; title = "ProvideMaxSlide"; ObjectID = "Dis-CN-0f1"; */
"Dis-CN-0f1.title" = "ProvideMaxSlide";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reuse original hibernate memory map.\n\nThis option forces the XNU kernel to ignore a newly supplied memory map and assume that it did not change after waking from hibernation. This behaviour is required by Windows to work. Windows mandates preserving runtime memory size and location after S4 wake.\n\nNote: This may be used to workaround defective memory map implementations on older, rare legacy hardware. Examples of such hardware are Ivy Bridge laptops with Insyde firmware such as the Acer V3-571G. Do not use this option without a full understanding of the implications."; ObjectID = "ELB-6s-GBW"; */
"ELB-6s-GBW.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Reuse original hibernate memory map.\n\nThis option forces the XNU kernel to ignore a newly supplied memory map and assume that it did not change after waking from hibernation. This behaviour is required by Windows to work. Windows mandates preserving runtime memory size and location after S4 wake.\n\nNote: This may be used to workaround defective memory map implementations on older, rare legacy hardware. Examples of such hardware are Ivy Bridge laptops with Insyde firmware such as the Acer V3-571G. Do not use this option without a full understanding of the implications.";

/* Class = "NSButtonCell"; title = "DisableVariableWrite"; ObjectID = "FY9-MP-Vsp"; */
"FY9-MP-Vsp.title" = "DisableVariableWrite";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Generate Memory Map compatible with macOS.\n\nThe Apple kernel has several limitations on parsing the UEFI memory map:\n• The Memory map size must not exceed 4096 bytes as the Apple kernel maps it as a single 4K page. As some types of firmware can have very large memory maps, potentially over 100 entries, the Apple kernel will crash on boot.\n• The Memory attributes table is ignored. EfiRuntimeServicesCode memory statically gets RX permissions while all other memory types get RW permissions. As some firmware drivers may write to global variables at runtime, the Apple kernel will crash at calling UEFI runtime services unless the driver .data section has a EfiRuntimeServicesData type.\n\nTo workaround these limitations, this quirk applies memory attribute table permissions to the memory map passed to the Apple kernel and optionally attempts to unify contiguous slots of similar types if the resulting memory map exceeds 4 KB.\n\nNote 1: Since several types of firmware come with incorrect memory protection tables, this quirk often comes paired with SyncRuntimePermissions.\n\nNote 2 : The need for this quirk is determined by early boot failures. This quirk replaces EnableWriteUnprotector on firmware supporting Memory Attribute Tables (MAT). This quirk is typically unnecessary when using OpenDuetPkg but may be required to boot macOS 10.6, and earlier, for reasons that are as yet unclear."; ObjectID = "JMF-hg-GgC"; */
"JMF-hg-GgC.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Generate Memory Map compatible with macOS.\n\nThe Apple kernel has several limitations on parsing the UEFI memory map:\n• The Memory map size must not exceed 4096 bytes as the Apple kernel maps it as a single 4K page. As some types of firmware can have very large memory maps, potentially over 100 entries, the Apple kernel will crash on boot.\n• The Memory attributes table is ignored. EfiRuntimeServicesCode memory statically gets RX permissions while all other memory types get RW permissions. As some firmware drivers may write to global variables at runtime, the Apple kernel will crash at calling UEFI runtime services unless the driver .data section has a EfiRuntimeServicesData type.\n\nTo workaround these limitations, this quirk applies memory attribute table permissions to the memory map passed to the Apple kernel and optionally attempts to unify contiguous slots of similar types if the resulting memory map exceeds 4 KB.\n\nNote 1: Since several types of firmware come with incorrect memory protection tables, this quirk often comes paired with SyncRuntimePermissions.\n\nNote 2 : The need for this quirk is determined by early boot failures. This quirk replaces EnableWriteUnprotector on firmware supporting Memory Attribute Tables (MAT). This quirk is typically unnecessary when using OpenDuetPkg but may be required to boot macOS 10.6, and earlier, for reasons that are as yet unclear.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Protect from macOS NVRAM write access.\nThis is a security option allowing one to restrict NVRAM access in macOS. This quirk requires OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi.\n\nNote: This quirk can also be used as an ad hoc workaround for defective UEFI runtime services implementations that are unable to write variables to NVRAM and results in operating system failures."; ObjectID = "KE8-rd-Ty5"; */
"KE8-rd-Ty5.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Protect from macOS NVRAM write access.\nThis is a security option allowing one to restrict NVRAM access in macOS. This quirk requires OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi.\n\nNote: This quirk can also be used as an ad hoc workaround for defective UEFI runtime services implementations that are unable to write variables to NVRAM and results in operating system failures.";

/* Class = "NSTabViewItem"; label = "Patch"; ObjectID = "N9f-29-rB5"; */
"N9f-29-rB5.label" = "Patch";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Remove runtime attribute from select MMIO regions.\n\nThis quirk reduces the stolen memory footprint in the memory map by removing the runtime bit for known memory regions. This quirk may result in an increase of KASLR slides available but without additional measures, it is not necessarily compatible with the target board. This quirk typically frees between 64 and 256 megabytes of memory, present in the debug log, and on some platforms, is the only way to boot macOS, which otherwise fails with allocation errors at the bootloader stage.\n\nThis option is useful on all types of firmware, except for some very old ones such as Sandy Bridge. On certain firmware, a list of addresses that need virtual addresses for proper NVRAM and hibernation functionality may be required. Use the MmioWhitelist section for this."; ObjectID = "NUB-EN-5ql"; */
"NUB-EN-5ql.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Remove runtime attribute from select MMIO regions.\n\nThis quirk reduces the stolen memory footprint in the memory map by removing the runtime bit for known memory regions. This quirk may result in an increase of KASLR slides available but without additional measures, it is not necessarily compatible with the target board. This quirk typically frees between 64 and 256 megabytes of memory, present in the debug log, and on some platforms, is the only way to boot macOS, which otherwise fails with allocation errors at the bootloader stage.\n\nThis option is useful on all types of firmware, except for some very old ones such as Sandy Bridge. On certain firmware, a list of addresses that need virtual addresses for proper NVRAM and hibernation functionality may be required. Use the MmioWhitelist section for this.";

/* Class = "NSBox"; title = "Quirks"; ObjectID = "PeB-9S-Amz"; */
"PeB-9S-Amz.title" = "Quirks";

/* Class = "NSButtonCell"; title = "RebuildAppleMemoryMap"; ObjectID = "Qht-28-YA5"; */
"Qht-28-YA5.title" = "RebuildAppleMemoryMap";

/* Class = "NSScrollView"; ibShadowedToolTip = "1. Address\nType: plist integer\nFailsafe: 0\nDescription: Exceptional MMIO address, which memory descriptor should be left virtualised (unchanged) by DevirtualiseMmio. This means that the firmware will be able to directly communicate with this memory region during operating system functioning, because the region this value is in will be assigned a virtual address.\n\nThe addresses written here must be part of the memory map, have EfiMemoryMappedIO type and EFI_MEMORY_RUNTIME attribute (highest bit) set. The debug log can be used to find the list of the candidates.\n2. Comment\nType: plist string\nFailsafe: Empty\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. Whether this value is used is implementation defined.\n3. Enabled\nType: plist boolean\nFailsafe: false\nDescription: Exclude MMIO address from the devirtualisation procedure."; ObjectID = "RWw-Gp-0A4"; */
"RWw-Gp-0A4.ibShadowedToolTip" = "1. Address\nType: plist integer\nFailsafe: 0\nDescription: Exceptional MMIO address, which memory descriptor should be left virtualised (unchanged) by DevirtualiseMmio. This means that the firmware will be able to directly communicate with this memory region during operating system functioning, because the region this value is in will be assigned a virtual address.\n\nThe addresses written here must be part of the memory map, have EfiMemoryMappedIO type and EFI_MEMORY_RUNTIME attribute (highest bit) set. The debug log can be used to find the list of the candidates.\n2. Comment\nType: plist string\nFailsafe: Empty\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. Whether this value is used is implementation defined.\n3. Enabled\nType: plist boolean\nFailsafe: false\nDescription: Exclude MMIO address from the devirtualisation procedure.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean \nFailsafe: false \nDescription: Report macOS being loaded through OS Info for any OS. \n\nThis quirk is useful on Mac firmwares, which behaves differently for different OS. For example, it is supposed to enable Intel GPU in Windows and Linux in some dual-GPU MacBook models."; ObjectID = "Ryj-m2-2MI"; */
"Ryj-m2-2MI.ibShadowedToolTip" = "Type: plist boolean \nFailsafe: false \nDescription: Report macOS being loaded through OS Info for any OS. \n\nThis quirk is useful on Mac firmwares, which behaves differently for different OS. For example, it is supposed to enable Intel GPU in Windows and Linux in some dual-GPU MacBook models.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Disable single user mode.\n\nThis is a security option that restricts the activation of single user mode by ignoring the CMD+S hotkey and the -s boot argument. The behaviour with this quirk enabled is supposed to match T2-based model behaviour."; ObjectID = "Ssn-0z-qIb"; */
"Ssn-0z-qIb.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Disable single user mode.\n\nThis is a security option that restricts the activation of single user mode by ignoring the CMD+S hotkey and the -s boot argument. The behaviour with this quirk enabled is supposed to match T2-based model behaviour.";

/* Class = "NSButtonCell"; title = "ProtectMemoryRegions"; ObjectID = "USC-aA-F2K"; */
"USC-aA-F2K.title" = "ProtectMemoryRegions";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean \nFailsafe: false\nDescription: Protect UEFI Secure Boot variables from being written.\n\nReports security violation during attempts to write to db, dbx, PK, and KEK variables from the operating system.\n\nNote: This quirk attempts to avoid issues with NVRAM implementations with fragmentation issues, such as on the MacPro5,1 as well as on certain Insyde firmware without garbage collection or with defective garbage collection."; ObjectID = "VnZ-XI-LOq"; */
"VnZ-XI-LOq.ibShadowedToolTip" = "Type: plist boolean \nFailsafe: false\nDescription: Protect UEFI Secure Boot variables from being written.\n\nReports security violation during attempts to write to db, dbx, PK, and KEK variables from the operating system.\n\nNote: This quirk attempts to avoid issues with NVRAM implementations with fragmentation issues, such as on the MacPro5,1 as well as on certain Insyde firmware without garbage collection or with defective garbage collection.";

/* Class = "NSTableColumn"; headerCell.title = "Address*"; ObjectID = "XBA-aR-mC0"; */
"XBA-aR-mC0.headerCell.title" = "Address*";

/* Class = "NSButtonCell"; title = "SyncRuntimePermissions"; ObjectID = "XIy-K6-Der"; */
"XIy-K6-Der.title" = "SyncRuntimePermissions";

/* Class = "NSButtonCell"; title = "EnableWriteUnprotector"; ObjectID = "XaK-gI-0aI"; */
"XaK-gI-0aI.title" = "EnableWriteUnprotector";

/* Class = "NSButtonCell"; title = "ProvideCustomSlide"; ObjectID = "a8S-kc-6sK"; */
"a8S-kc-6sK.title" = "ProvideCustomSlide";

/* Class = "NSButtonCell"; title = "DisableSingleUser"; ObjectID = "bMR-Kw-wwp"; */
"bMR-Kw-wwp.title" = "DisableSingleUser";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Allows booting macOS through a relocation block.\n\nThe relocation block is a scratch buffer allocated in the lower 4 GB used for loading the kernel and related structures by EfiBoot on firmware where the lower memory region is otherwise occupied by (assumed) non-runtime data. Right before kernel startup, the relocation block is copied back to lower addresses. Similarly, all the other addresses pointing to the relocation block are also carefully adjusted. The relocation block can be used when:\n• No better slide exists (all the memory is used)\n• slide=0 is forced (by an argument or safe mode)\n• KASLR (slide) is unsupported (this is macOS 10.7 or older)\n\nThis quirk requires ProvideCustomSlide to be enabled and typically also requires enabling AvoidRuntimeDefrag to function correctly. Hibernation is not supported when booting with a relocation block, which will only be used if required when the quirk is enabled.\n\nNote: While this quirk is required to run older macOS versions on platforms with used lower memory, it is not compatible with some hardware and macOS 11. In such cases, consider using EnableSafeModeSlide instead."; ObjectID = "bib-aL-YwI"; */
"bib-aL-YwI.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Allows booting macOS through a relocation block.\n\nThe relocation block is a scratch buffer allocated in the lower 4 GB used for loading the kernel and related structures by EfiBoot on firmware where the lower memory region is otherwise occupied by (assumed) non-runtime data. Right before kernel startup, the relocation block is copied back to lower addresses. Similarly, all the other addresses pointing to the relocation block are also carefully adjusted. The relocation block can be used when:\n• No better slide exists (all the memory is used)\n• slide=0 is forced (by an argument or safe mode)\n• KASLR (slide) is unsupported (this is macOS 10.7 or older)\n\nThis quirk requires ProvideCustomSlide to be enabled and typically also requires enabling AvoidRuntimeDefrag to function correctly. Hibernation is not supported when booting with a relocation block, which will only be used if required when the quirk is enabled.\n\nNote: While this quirk is required to run older macOS versions on platforms with used lower memory, it is not compatible with some hardware and macOS 11. In such cases, consider using EnableSafeModeSlide instead.";

/* Class = "NSTableColumn"; headerCell.title = "Enabled"; ObjectID = "c3O-jR-hal"; */
"c3O-jR-hal.headerCell.title" = "Enabled";

/* Class = "NSTableColumn"; headerCell.title = "Count"; ObjectID = "cCx-7g-cuM"; */
"cCx-7g-cuM.headerCell.title" = "Count";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Retry ExitBootServices with new memory map on failure.\n\nTry to ensure that the ExitBootServices call succeeds. If required, an outdated MemoryMap key argument can be used by obtaining the current memory map and retrying the ExitBootServices call.\n\nNote: The need for this quirk is determined by early boot crashes of the firmware. Do not use this option without a full understanding of the implications."; ObjectID = "cTN-CD-c3M"; */
"cTN-CD-c3M.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Retry ExitBootServices with new memory map on failure.\n\nTry to ensure that the ExitBootServices call succeeds. If required, an outdated MemoryMap key argument can be used by obtaining the current memory map and retrying the ExitBootServices call.\n\nNote: The need for this quirk is determined by early boot crashes of the firmware. Do not use this option without a full understanding of the implications.";

/* Class = "NSTableColumn"; headerCell.title = "Skip"; ObjectID = "dwb-DP-v4I"; */
"dwb-DP-v4I.headerCell.title" = "Skip";

/* Class = "NSTableColumn"; headerCell.title = "Comment"; ObjectID = "f4e-pW-Orc"; */
"f4e-pW-Orc.headerCell.title" = "Comment";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Provide maximum KASLR slide when higher ones are unavailable.\n\nThis option overrides the maximum slide of 255 by a user specified value between 1 and 254 (inclusive) when ProvideCustomSlide is enabled. It is assumed that modern firmware allocates pool memory from top to bottom, effectively resulting in free memory when slide scanning is used later as temporary memory during kernel loading. When such memory is not available, this option stops the evaluation of higher slides.\n\nNote: The need for this quirk is determined by random boot failures when ProvideCustomSlide is enabled and the randomized slide falls into the unavailable range. When AppleDebug is enabled, the debug log typically contains messages such as AAPL: [EB|‘LD:LKC] } Err(0x9). To find the optimal value, append slide=X, where X is the slide value, to the boot-args and select the largest one that does not result in boot failures."; ObjectID = "gi2-WY-dKJ"; */
"gi2-WY-dKJ.ibShadowedToolTip" = "Type: plist integer\nFailsafe: 0\nDescription: Provide maximum KASLR slide when higher ones are unavailable.\n\nThis option overrides the maximum slide of 255 by a user specified value between 1 and 254 (inclusive) when ProvideCustomSlide is enabled. It is assumed that modern firmware allocates pool memory from top to bottom, effectively resulting in free memory when slide scanning is used later as temporary memory during kernel loading. When such memory is not available, this option stops the evaluation of higher slides.\n\nNote: The need for this quirk is determined by random boot failures when ProvideCustomSlide is enabled and the randomized slide falls into the unavailable range. When AppleDebug is enabled, the debug log typically contains messages such as AAPL: [EB|‘LD:LKC] } Err(0x9). To find the optimal value, append slide=X, where X is the slide value, to the boot-args and select the largest one that does not result in boot failures.";

/* Class = "NSButtonCell"; title = "EnableForAll"; ObjectID = "hF2-W3-w6Y"; */
"hF2-W3-w6Y.title" = "EnableForAll";

/* Class = "NSTableColumn"; headerCell.title = "ReplaceMask"; ObjectID = "jK8-UP-6rI"; */
"jK8-UP-6rI.headerCell.title" = "ReplaceMask";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Setup virtual memory at SetVirtualAddresses.\n\nSome types of firmware access memory by virtual addresses after a SetVirtualAddresses call, resulting in early boot crashes. This quirk workarounds the problem by performing early boot identity mapping of assigned virtual addresses to physical memory.\n\nNote: The need for this quirk is determined by early boot failures."; ObjectID = "l3S-mh-5k0"; */
"l3S-mh-5k0.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Setup virtual memory at SetVirtualAddresses.\n\nSome types of firmware access memory by virtual addresses after a SetVirtualAddresses call, resulting in early boot crashes. This quirk workarounds the problem by performing early boot identity mapping of assigned virtual addresses to physical memory.\n\nNote: The need for this quirk is determined by early boot failures.";

/* Class = "NSTabViewItem"; label = "MmioWhitelist"; ObjectID = "mrQ-IT-UQ3"; */
"mrQ-IT-UQ3.label" = "MmioWhitelist";

/* Class = "NSTableColumn"; headerCell.title = "Replace"; ObjectID = "mtD-yq-Tub"; */
"mtD-yq-Tub.headerCell.title" = "Replace";

/* Class = "NSTableColumn"; headerCell.title = "Comment"; ObjectID = "ndf-NP-2rM"; */
"ndf-NP-2rM.headerCell.title" = "Comment";

/* Class = "NSButtonCell"; title = "AllowRelocationBlock"; ObjectID = "oFh-ac-Blm"; */
"oFh-ac-Blm.title" = "AllowRelocationBlock";

/* Class = "NSTableView"; ibShadowedToolTip = "1. Arch\nType: plist string\nFailsafe: Any (Apply to any supported architecture)\nDescription: Booter patch architecture (i386, x86_64).\n2. Comment\nType: plist string\nFailsafe: Empty\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. Whether this value is used is implementation defined.\n3. Count\nType: plist integer\nFailsafe: 0 (Apply to all occurrences found)\nDescription: Number of patch occurrences to apply.\n4. Enabled\nType: plist boolean\nFailsafe: false\nDescription: Set to true to activate this booter patch.\n5. Find\nType: plist data\nFailsafe: Empty\nDescription: Data to find. This must be equal to Replace in size if set.\n6. Identifier\nType: plist string\nFailsafe: Any (Match any booter)\nDescription: Apple for macOS booter (typically boot.efi); or a name with a suffix, such as  bootmgfw.efi for a specific booter.\n7. Limit\nType: plist integer\nFailsafe: 0 (Search the entire booter)\nDescription: Maximum number of bytes to search for.\n8. Mask\nType: plist data\nFailsafe: Empty (Ignored)\nDescription: Data bitwise mask used during find comparison. Allows fuzzy search by ignoring not masked (set to zero) bits. Must be equal to Find in size if set.\n9. Replace\nType: plist data\nFailsafe: Empty\nDescription: Replacement data of one or more bytes.\n10. ReplaceMask\nType: plist data\nFailsafe: Empty (Ignored)\nDescription: Data bitwise mask used during replacement. Allows fuzzy replacement by updating masked (set to non-zero) bits. Must be equal to Replace in size if set.\n11. Skip\nType: plist integer\nFailsafe: 0 (Do not skip any occurrences)\nDescription: Number of found occurrences to skip before replacements are applied."; ObjectID = "oWj-qp-bH5"; */
"oWj-qp-bH5.ibShadowedToolTip" = "1. Arch\nType: plist string\nFailsafe: Any (Apply to any supported architecture)\nDescription: Booter patch architecture (i386, x86_64).\n2. Comment\nType: plist string\nFailsafe: Empty\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. Whether this value is used is implementation defined.\n3. Count\nType: plist integer\nFailsafe: 0 (Apply to all occurrences found)\nDescription: Number of patch occurrences to apply.\n4. Enabled\nType: plist boolean\nFailsafe: false\nDescription: Set to true to activate this booter patch.\n5. Find\nType: plist data\nFailsafe: Empty\nDescription: Data to find. This must be equal to Replace in size if set.\n6. Identifier\nType: plist string\nFailsafe: Any (Match any booter)\nDescription: Apple for macOS booter (typically boot.efi); or a name with a suffix, such as  bootmgfw.efi for a specific booter.\n7. Limit\nType: plist integer\nFailsafe: 0 (Search the entire booter)\nDescription: Maximum number of bytes to search for.\n8. Mask\nType: plist data\nFailsafe: Empty (Ignored)\nDescription: Data bitwise mask used during find comparison. Allows fuzzy search by ignoring not masked (set to zero) bits. Must be equal to Find in size if set.\n9. Replace\nType: plist data\nFailsafe: Empty\nDescription: Replacement data of one or more bytes.\n10. ReplaceMask\nType: plist data\nFailsafe: Empty (Ignored)\nDescription: Data bitwise mask used during replacement. Allows fuzzy replacement by updating masked (set to non-zero) bits. Must be equal to Replace in size if set.\n11. Skip\nType: plist integer\nFailsafe: 0 (Do not skip any occurrences)\nDescription: Number of found occurrences to skip before replacements are applied.";

/* Class = "NSButtonCell"; title = "DevirtualiseMmio"; ObjectID = "pkh-Nr-Lgr"; */
"pkh-Nr-Lgr.title" = "DevirtualiseMmio";

/* Class = "NSButtonCell"; title = "AvoidRuntimeDefrag"; ObjectID = "quR-9w-VV5"; */
"quR-9w-VV5.title" = "AvoidRuntimeDefrag";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Patch bootloader to have KASLR enabled in safe mode.\n\nThis option is relevant to users with issues booting to safe mode (e.g. by holding shift or with using the -x boot argument). By default, safe mode forces 0 slide as if the system was launched with the slide=0 boot argument.\n• This quirk attempts to patch the boot.efi file to remove this limitation and to allow using other values (from 1 to 255 inclusive).\n• This quirk requires enabling ProvideCustomSlide.\n\nNote: The need for this option is dependent on the availability of safe mode. It can be enabled when booting to safe mode fails."; ObjectID = "qyH-8f-uTZ"; */
"qyH-8f-uTZ.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Patch bootloader to have KASLR enabled in safe mode.\n\nThis option is relevant to users with issues booting to safe mode (e.g. by holding shift or with using the -x boot argument). By default, safe mode forces 0 slide as if the system was launched with the slide=0 boot argument.\n• This quirk attempts to patch the boot.efi file to remove this limitation and to allow using other values (from 1 to 255 inclusive).\n• This quirk requires enabling ProvideCustomSlide.\n\nNote: The need for this option is dependent on the availability of safe mode. It can be enabled when booting to safe mode fails.";

/* Class = "NSButtonCell"; title = "ProtectSecureBoot"; ObjectID = "rWG-6j-Mxs"; */
"rWG-6j-Mxs.title" = "ProtectSecureBoot";

/* Class = "NSButtonCell"; title = "ForceBooterSignature"; ObjectID = "sHw-qr-Pag"; */
"sHw-qr-Pag.title" = "ForceBooterSignature";

/* Class = "NSButtonCell"; title = "SetupVirtualMap"; ObjectID = "sNx-S4-Yhl"; */
"sNx-S4-Yhl.title" = "SetupVirtualMap";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Protect from boot.efi runtime memory defragmentation.\n\nThis option fixes UEFI runtime services (date, time, NVRAM, power control, etc.) support on firmware that uses SMM backing for certain services such as variable storage. SMM may try to access memory by physical addresses in non-SMM areas but this may sometimes have been moved by boot.efi. This option prevents boot.efi from moving such data.\n\nNote: Most types of firmware, apart from Apple and VMware, need this quirk."; ObjectID = "ubm-2i-zPE"; */
"ubm-2i-zPE.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Protect from boot.efi runtime memory defragmentation.\n\nThis option fixes UEFI runtime services (date, time, NVRAM, power control, etc.) support on firmware that uses SMM backing for certain services such as variable storage. SMM may try to access memory by physical addresses in non-SMM areas but this may sometimes have been moved by boot.efi. This option prevents boot.efi from moving such data.\n\nNote: Most types of firmware, apart from Apple and VMware, need this quirk.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Provide custom KASLR slide on low memory.\n\nThis option performs memory map analysis of the firmware and checks whether all slides (from 1 to 255) can be used. As boot.efi generates this value randomly with rdrand or pseudo randomly rdtsc, there is a chance of boot failure when it chooses a conflicting slide. In cases where potential conflicts exist, this option forces macOS to select a pseudo random value from the available values. This also ensures that the slide= argument is never passed to the operating system (for security reasons).\n\nNote: The need for this quirk is determined by the OCABC: Only N/256 slide values are usable! message in the debug log."; ObjectID = "wGH-hP-xhD"; */
"wGH-hP-xhD.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Provide custom KASLR slide on low memory.\n\nThis option performs memory map analysis of the firmware and checks whether all slides (from 1 to 255) can be used. As boot.efi generates this value randomly with rdrand or pseudo randomly rdtsc, there is a chance of boot failure when it chooses a conflicting slide. In cases where potential conflicts exist, this option forces macOS to select a pseudo random value from the available values. This also ensures that the slide= argument is never passed to the operating system (for security reasons).\n\nNote: The need for this quirk is determined by the OCABC: Only N/256 slide values are usable! message in the debug log.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Set macOS boot-signature to OpenCore launcher.\n\nBooter signature, essentially a SHA-1 hash of the loaded image, is used by Mac EFI to verify the authenticity of the bootloader when waking from hibernation. This option forces macOS to use OpenCore launcher SHA-1 hash as a booter signature to let OpenCore shim hibernation wake on Mac EFI firmware.\n\nNote: OpenCore launcher path is determined from LauncherPath property."; ObjectID = "woE-nK-MFN"; */
"woE-nK-MFN.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Set macOS boot-signature to OpenCore launcher.\n\nBooter signature, essentially a SHA-1 hash of the loaded image, is used by Mac EFI to verify the authenticity of the bootloader when waking from hibernation. This option forces macOS to use OpenCore launcher SHA-1 hash as a booter signature to let OpenCore shim hibernation wake on Mac EFI firmware.\n\nNote: OpenCore launcher path is determined from LauncherPath property.";

/* Class = "NSTableColumn"; headerCell.title = "Limit"; ObjectID = "xEr-hF-nBr"; */
"xEr-hF-nBr.headerCell.title" = "Limit";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Permit write access to UEFI runtime services code.\n\nThis option bypasses RˆX permissions in code pages of UEFI runtime services by removing write protection (WP) bit from CR0 register during their execution. This quirk requires OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi.\n\nNote: This quirk may potentially weaken firmware security. Please use RebuildAppleMemoryMap if the firmware supports memory attributes table (MAT). Refer to the OCABC: MAT support is 1/0 log entry to determine wheter MAT is supported."; ObjectID = "xH6-La-kRg"; */
"xH6-La-kRg.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Permit write access to UEFI runtime services code.\n\nThis option bypasses RˆX permissions in code pages of UEFI runtime services by removing write protection (WP) bit from CR0 register during their execution. This quirk requires OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi.\n\nNote: This quirk may potentially weaken firmware security. Please use RebuildAppleMemoryMap if the firmware supports memory attributes table (MAT). Refer to the OCABC: MAT support is 1/0 log entry to determine wheter MAT is supported.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Update memory permissions for the runtime environment.\n\nSome types of firmware fail to properly handle runtime permissions:\n• They incorrectly mark OpenRuntime as not executable in the memory map.\n• They incorrectly mark OpenRuntime as not executable in the memory attributes table.\n• They lose entries from the memory attributes table after OpenRuntime is loaded.\n• They mark items in the memory attributes table as read-write-execute.\n\nThis quirk attempts to update the memory map and memory attributes table to correct this.\n\nNote: The need for this quirk is indicated by early boot failures . Only firmware released after 2017 is typically affected."; ObjectID = "ymv-yt-Lvn"; */
"ymv-yt-Lvn.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Update memory permissions for the runtime environment.\n\nSome types of firmware fail to properly handle runtime permissions:\n• They incorrectly mark OpenRuntime as not executable in the memory map.\n• They incorrectly mark OpenRuntime as not executable in the memory attributes table.\n• They lose entries from the memory attributes table after OpenRuntime is loaded.\n• They mark items in the memory attributes table as read-write-execute.\n\nThis quirk attempts to update the memory map and memory attributes table to correct this.\n\nNote: The need for this quirk is indicated by early boot failures . Only firmware released after 2017 is typically affected.";
